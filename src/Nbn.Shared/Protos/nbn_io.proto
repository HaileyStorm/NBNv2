syntax = "proto3";
package nbn.io;

option csharp_namespace = "Nbn.Proto.Io";

import "nbn_common.proto";
import "nbn_control.proto";
import "nbn_repro.proto";
import "nbn_signals.proto";

message Connect {
  string client_name = 1;
}

message ConnectAck {
  string server_name = 1;
  fixed64 server_time_ms = 2;
}

message BrainInfoRequest {
  nbn.Uuid brain_id = 1;
}

message BrainInfo {
  nbn.Uuid brain_id = 1;
  uint32 input_width = 2;
  uint32 output_width = 3;

  bool cost_enabled = 4;
  bool energy_enabled = 5;
  sint64 energy_remaining = 6;

  bool plasticity_enabled = 7;
  nbn.ArtifactRef base_definition = 8;
  nbn.ArtifactRef last_snapshot = 9;
  sint64 energy_rate_units_per_second = 10;
  float plasticity_rate = 11;
  bool plasticity_probabilistic_updates = 12;
  sint64 last_tick_cost = 13;
  bool homeostasis_enabled = 14;
  nbn.control.HomeostasisTargetMode homeostasis_target_mode = 15;
  nbn.control.HomeostasisUpdateMode homeostasis_update_mode = 16;
  float homeostasis_base_probability = 17;
  uint32 homeostasis_min_step_codes = 18;
  bool homeostasis_energy_coupling_enabled = 19;
  float homeostasis_energy_target_scale = 20;
  float homeostasis_energy_probability_scale = 21;
  float plasticity_delta = 22;
  uint32 plasticity_rebase_threshold = 23;
  float plasticity_rebase_threshold_pct = 24;
  bool plasticity_energy_cost_modulation_enabled = 25;
  sint64 plasticity_energy_cost_reference_tick_cost = 26;
  float plasticity_energy_cost_response_strength = 27;
  float plasticity_energy_cost_min_scale = 28;
  float plasticity_energy_cost_max_scale = 29;
  nbn.control.InputCoordinatorMode input_coordinator_mode = 30;
  nbn.control.OutputVectorSource output_vector_source = 31;
}

message BrainEnergyState {
  sint64 energy_remaining = 1;
  sint64 energy_rate_units_per_second = 2;
  bool cost_enabled = 3;
  bool energy_enabled = 4;
  bool plasticity_enabled = 5;
  float plasticity_rate = 6;
  bool plasticity_probabilistic_updates = 7;
  sint64 last_tick_cost = 8;
  bool homeostasis_enabled = 9;
  nbn.control.HomeostasisTargetMode homeostasis_target_mode = 10;
  nbn.control.HomeostasisUpdateMode homeostasis_update_mode = 11;
  float homeostasis_base_probability = 12;
  uint32 homeostasis_min_step_codes = 13;
  bool homeostasis_energy_coupling_enabled = 14;
  float homeostasis_energy_target_scale = 15;
  float homeostasis_energy_probability_scale = 16;
  float plasticity_delta = 17;
  uint32 plasticity_rebase_threshold = 18;
  float plasticity_rebase_threshold_pct = 19;
  bool plasticity_energy_cost_modulation_enabled = 20;
  sint64 plasticity_energy_cost_reference_tick_cost = 21;
  float plasticity_energy_cost_response_strength = 22;
  float plasticity_energy_cost_min_scale = 23;
  float plasticity_energy_cost_max_scale = 24;
}

message RegisterBrain {
  nbn.Uuid brain_id = 1;
  uint32 input_width = 2;
  uint32 output_width = 3;
  nbn.ArtifactRef base_definition = 4;
  nbn.ArtifactRef last_snapshot = 5;
  BrainEnergyState energy_state = 6;
  bool has_runtime_config = 7;
  bool cost_enabled = 8;
  bool energy_enabled = 9;
  bool plasticity_enabled = 10;
  float plasticity_rate = 11;
  bool plasticity_probabilistic_updates = 12;
  sint64 last_tick_cost = 13;
  bool homeostasis_enabled = 14;
  nbn.control.HomeostasisTargetMode homeostasis_target_mode = 15;
  nbn.control.HomeostasisUpdateMode homeostasis_update_mode = 16;
  float homeostasis_base_probability = 17;
  uint32 homeostasis_min_step_codes = 18;
  bool homeostasis_energy_coupling_enabled = 19;
  float homeostasis_energy_target_scale = 20;
  float homeostasis_energy_probability_scale = 21;
  float plasticity_delta = 22;
  uint32 plasticity_rebase_threshold = 23;
  float plasticity_rebase_threshold_pct = 24;
  bool plasticity_energy_cost_modulation_enabled = 25;
  sint64 plasticity_energy_cost_reference_tick_cost = 26;
  float plasticity_energy_cost_response_strength = 27;
  float plasticity_energy_cost_min_scale = 28;
  float plasticity_energy_cost_max_scale = 29;
  nbn.control.InputCoordinatorMode input_coordinator_mode = 30;
  nbn.control.OutputVectorSource output_vector_source = 31;
}

message UnregisterBrain {
  nbn.Uuid brain_id = 1;
  string reason = 2;
}

message RegisterIoGateway {
  nbn.Uuid brain_id = 1;
  string io_gateway_pid = 2; // "address/id" or "id" if local
}

message SpawnBrainViaIO {
  nbn.control.SpawnBrain request = 1;
}

message SpawnBrainViaIOAck {
  nbn.control.SpawnBrainAck ack = 1;
  string failure_reason_code = 2;
  string failure_message = 3;
}

message InputWrite {
  nbn.Uuid brain_id = 1;
  uint32 input_index = 2;
  float value = 3;
}

message InputVector {
  nbn.Uuid brain_id = 1;
  repeated float values = 2;
}

message RuntimeNeuronPulse {
  nbn.Uuid brain_id = 1;
  uint32 target_region_id = 2;
  uint32 target_neuron_id = 3;
  float value = 4;
}

message RuntimeNeuronStateWrite {
  nbn.Uuid brain_id = 1;
  uint32 target_region_id = 2;
  uint32 target_neuron_id = 3;
  bool set_buffer = 4;
  float buffer_value = 5;
  bool set_accumulator = 6;
  float accumulator_value = 7;
}

message DrainInputs {
  nbn.Uuid brain_id = 1;
  fixed64 tick_id = 2;
}

message InputDrain {
  nbn.Uuid brain_id = 1;
  fixed64 tick_id = 2;
  repeated nbn.signal.Contribution contribs = 3;
}

message SubscribeOutputs {
  nbn.Uuid brain_id = 1;
  string subscriber_actor = 2; // optional explicit subscriber pid label ("address/id" or "id")
}

message UnsubscribeOutputs {
  nbn.Uuid brain_id = 1;
  string subscriber_actor = 2; // optional explicit subscriber pid label ("address/id" or "id")
}

message OutputEvent {
  nbn.Uuid brain_id = 1;
  uint32 output_index = 2;
  float value = 3;
  fixed64 tick_id = 4;
}

message SubscribeOutputsVector {
  nbn.Uuid brain_id = 1;
  string subscriber_actor = 2; // optional explicit subscriber pid label ("address/id" or "id")
}

message UnsubscribeOutputsVector {
  nbn.Uuid brain_id = 1;
  string subscriber_actor = 2; // optional explicit subscriber pid label ("address/id" or "id")
}

message OutputVectorEvent {
  nbn.Uuid brain_id = 1;
  fixed64 tick_id = 2;
  // Published by IO as a full brain-level vector ordered by output_index (0..output_width-1).
  // For sharded output regions, IO assembles shard-local segments before publication.
  repeated float values = 3;
}

message OutputVectorSegment {
  nbn.Uuid brain_id = 1;
  fixed64 tick_id = 2;
  uint32 output_index_start = 3;
  repeated float values = 4;
}

message EnergyCredit {
  nbn.Uuid brain_id = 1;
  sint64 amount = 2;
}

message EnergyRate {
  nbn.Uuid brain_id = 1;
  sint64 units_per_second = 2;
}

message SetCostEnergyEnabled {
  nbn.Uuid brain_id = 1;
  bool cost_enabled = 2;
  bool energy_enabled = 3;
}

message SetPlasticityEnabled {
  nbn.Uuid brain_id = 1;
  bool plasticity_enabled = 2;
  float plasticity_rate = 3;
  bool probabilistic_updates = 4;
  float plasticity_delta = 5;
  uint32 plasticity_rebase_threshold = 6;
  float plasticity_rebase_threshold_pct = 7;
  bool plasticity_energy_cost_modulation_enabled = 8;
  sint64 plasticity_energy_cost_reference_tick_cost = 9;
  float plasticity_energy_cost_response_strength = 10;
  float plasticity_energy_cost_min_scale = 11;
  float plasticity_energy_cost_max_scale = 12;
}

message SetHomeostasisEnabled {
  nbn.Uuid brain_id = 1;
  bool homeostasis_enabled = 2;
  nbn.control.HomeostasisTargetMode homeostasis_target_mode = 3;
  nbn.control.HomeostasisUpdateMode homeostasis_update_mode = 4;
  float homeostasis_base_probability = 5;
  uint32 homeostasis_min_step_codes = 6;
  bool homeostasis_energy_coupling_enabled = 7;
  float homeostasis_energy_target_scale = 8;
  float homeostasis_energy_probability_scale = 9;
}

message IoCommandAck {
  nbn.Uuid brain_id = 1;
  string command = 2;
  bool success = 3;
  string message = 4;
  bool has_energy_state = 5;
  BrainEnergyState energy_state = 6;
  bool has_configured_plasticity_enabled = 7;
  bool configured_plasticity_enabled = 8;
  bool has_effective_plasticity_enabled = 9;
  bool effective_plasticity_enabled = 10;
}

message RequestSnapshot {
  nbn.Uuid brain_id = 1;
  bool has_runtime_state = 2;
  sint64 energy_remaining = 3;
  bool cost_enabled = 4;
  bool energy_enabled = 5;
  bool plasticity_enabled = 6;
}

message SnapshotReady {
  nbn.Uuid brain_id = 1;
  nbn.ArtifactRef snapshot = 2; // .nbs
}

message ExportBrainDefinition {
  nbn.Uuid brain_id = 1;
  bool rebase_overlays = 2; // if true, incorporate overlays into base .nbn
}

message BrainDefinitionReady {
  nbn.Uuid brain_id = 1;
  nbn.ArtifactRef brain_def = 2; // .nbn
}

message ReproduceByBrainIds {
  nbn.repro.ReproduceByBrainIdsRequest request = 1;
}

message ReproduceByArtifacts {
  nbn.repro.ReproduceByArtifactsRequest request = 1;
}

message ReproduceResult {
  nbn.repro.ReproduceResult result = 1;
}
