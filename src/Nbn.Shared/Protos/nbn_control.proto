syntax = "proto3";
package nbn.control;

option csharp_namespace = "Nbn.Proto.Control";

import "nbn_common.proto";

message SpawnBrain {
  nbn.ArtifactRef brain_def = 1; // .nbn
}

message SpawnBrainAck {
  nbn.Uuid brain_id = 1;
}

message PauseBrain {
  nbn.Uuid brain_id = 1;
  string reason = 2;
}

message ResumeBrain {
  nbn.Uuid brain_id = 1;
}

message RegisterBrain {
  nbn.Uuid brain_id = 1;
  string brain_root_pid = 2;
  string signal_router_pid = 3;
}

message UpdateBrainSignalRouter {
  nbn.Uuid brain_id = 1;
  string signal_router_pid = 2;
}

message UnregisterBrain {
  nbn.Uuid brain_id = 1;
}

message RegisterShard {
  nbn.Uuid brain_id = 1;
  uint32 region_id = 2;
  uint32 shard_index = 3;
  string shard_pid = 4;
  uint32 neuron_start = 5;
  uint32 neuron_count = 6;
}

message UnregisterShard {
  nbn.Uuid brain_id = 1;
  uint32 region_id = 2;
  uint32 shard_index = 3;
}

message RegisterOutputSink {
  nbn.Uuid brain_id = 1;
  string output_pid = 2;
}

message SetBrainVisualization {
  nbn.Uuid brain_id = 1;
  bool enabled = 2;
  bool has_focus_region = 3;
  uint32 focus_region_id = 4;
}

message UpdateShardOutputSink {
  nbn.Uuid brain_id = 1;
  uint32 region_id = 2;
  uint32 shard_index = 3;
  string output_pid = 4; // empty clears
}

message UpdateShardVisualization {
  nbn.Uuid brain_id = 1;
  uint32 region_id = 2;
  uint32 shard_index = 3;
  bool enabled = 4;
  bool has_focus_region = 5;
  uint32 focus_region_id = 6;
}

message GetBrainIoInfo {
  nbn.Uuid brain_id = 1;
}

message BrainIoInfo {
  nbn.Uuid brain_id = 1;
  uint32 input_width = 2;
  uint32 output_width = 3;
}

enum ShardPlanMode {
  SHARD_PLAN_SINGLE = 0;
  SHARD_PLAN_FIXED = 1;
  SHARD_PLAN_MAX_NEURONS = 2;
}

message ShardPlan {
  ShardPlanMode mode = 1;
  uint32 shard_count = 2;
  uint32 max_neurons_per_shard = 3;
}

message RequestPlacement {
  nbn.Uuid brain_id = 1;
  nbn.ArtifactRef base_def = 2;
  nbn.ArtifactRef last_snapshot = 3;
  ShardPlan shard_plan = 4;
  uint32 input_width = 5;
  uint32 output_width = 6;
}

message PlacementAck {
  bool accepted = 1;
  string message = 2;
}

message KillBrain {
  nbn.Uuid brain_id = 1;
  string reason = 2;
}

message BrainTerminated {
  nbn.Uuid brain_id = 1;
  string reason = 2;
  nbn.ArtifactRef base_def = 3;       // .nbn
  nbn.ArtifactRef last_snapshot = 4;  // .nbs (optional; may be empty sha)
  sint64 last_energy_remaining = 5;
  sint64 last_tick_cost = 6;
  fixed64 time_ms = 7;
}

message TickCompute {
  fixed64 tick_id = 1;
  float target_tick_hz = 2;
}

message TickComputeDone {
  fixed64 tick_id = 1;
  nbn.Uuid brain_id = 2;
  uint32 region_id = 3;
  nbn.ShardId32 shard_id = 4;

  fixed64 compute_ms = 5;

  sint64 tick_cost_total = 6;
  sint64 cost_accum = 7;
  sint64 cost_activation = 8;
  sint64 cost_reset = 9;
  sint64 cost_distance = 10;
  sint64 cost_remote = 11;

  uint32 fired_count = 12;
  uint32 out_batches = 13;
  uint32 out_contribs = 14;
}

message TickDeliver {
  fixed64 tick_id = 1;
}

message TickDeliverDone {
  fixed64 tick_id = 1;
  nbn.Uuid brain_id = 2;
  fixed64 deliver_ms = 3;
  uint32 delivered_batches = 4;
  uint32 delivered_contribs = 5;
}

message GetHiveMindStatus { }

message SetTickRateOverride {
  bool clear_override = 1;
  float target_tick_hz = 2;
}

message SetTickRateOverrideAck {
  bool accepted = 1;
  string message = 2;
  float target_tick_hz = 3;
  bool has_override = 4;
  float override_tick_hz = 5;
}

message HiveMindStatus {
  fixed64 last_completed_tick_id = 1;
  bool tick_loop_enabled = 2;
  float target_tick_hz = 3;
  uint32 pending_compute = 4;
  uint32 pending_deliver = 5;
  bool reschedule_in_progress = 6;
  uint32 registered_brains = 7;
  uint32 registered_shards = 8;
  bool has_tick_rate_override = 9;
  float tick_rate_override_hz = 10;
}

message GetBrainRouting {
  nbn.Uuid brain_id = 1;
}

message BrainRoutingInfo {
  nbn.Uuid brain_id = 1;
  string brain_root_pid = 2;
  string signal_router_pid = 3;
  uint32 shard_count = 4;
  uint32 routing_count = 5;
}
