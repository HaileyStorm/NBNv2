syntax = "proto3";
package nbn.control;

option csharp_namespace = "Nbn.Proto.Control";

import "nbn_common.proto";

message SpawnBrain {
  nbn.ArtifactRef brain_def = 1; // .nbn
}

message SpawnBrainAck {
  nbn.Uuid brain_id = 1;
  string failure_reason_code = 2;
  string failure_message = 3;
}

message PauseBrain {
  nbn.Uuid brain_id = 1;
  string reason = 2;
}

message ResumeBrain {
  nbn.Uuid brain_id = 1;
}

message RegisterBrain {
  nbn.Uuid brain_id = 1;
  string brain_root_pid = 2;
  string signal_router_pid = 3;
}

message UpdateBrainSignalRouter {
  nbn.Uuid brain_id = 1;
  string signal_router_pid = 2;
}

message UnregisterBrain {
  nbn.Uuid brain_id = 1;
}

message RegisterShard {
  nbn.Uuid brain_id = 1;
  uint32 region_id = 2;
  uint32 shard_index = 3;
  string shard_pid = 4;
  uint32 neuron_start = 5;
  uint32 neuron_count = 6;
}

message UnregisterShard {
  nbn.Uuid brain_id = 1;
  uint32 region_id = 2;
  uint32 shard_index = 3;
}

message RegisterOutputSink {
  nbn.Uuid brain_id = 1;
  string output_pid = 2;
}

message SetBrainVisualization {
  nbn.Uuid brain_id = 1;
  bool enabled = 2;
  bool has_focus_region = 3;
  uint32 focus_region_id = 4;
  string subscriber_actor = 5; // optional stable subscriber identity (actor path/id)
}

message SetBrainCostEnergy {
  nbn.Uuid brain_id = 1;
  bool cost_enabled = 2;
  bool energy_enabled = 3;
}

message SetBrainPlasticity {
  nbn.Uuid brain_id = 1;
  bool plasticity_enabled = 2;
  float plasticity_rate = 3;
  bool probabilistic_updates = 4;
  float plasticity_delta = 5;
  uint32 plasticity_rebase_threshold = 6;
  float plasticity_rebase_threshold_pct = 7;
}

enum HomeostasisTargetMode {
  HOMEOSTASIS_TARGET_ZERO = 0;
  HOMEOSTASIS_TARGET_FIXED = 1;
}

enum HomeostasisUpdateMode {
  HOMEOSTASIS_UPDATE_PROBABILISTIC_QUANTIZED_STEP = 0;
}

message SetBrainHomeostasis {
  nbn.Uuid brain_id = 1;
  bool homeostasis_enabled = 2;
  HomeostasisTargetMode homeostasis_target_mode = 3;
  HomeostasisUpdateMode homeostasis_update_mode = 4;
  float homeostasis_base_probability = 5;
  uint32 homeostasis_min_step_codes = 6;
  bool homeostasis_energy_coupling_enabled = 7;
  float homeostasis_energy_target_scale = 8;
  float homeostasis_energy_probability_scale = 9;
}

message UpdateShardOutputSink {
  nbn.Uuid brain_id = 1;
  uint32 region_id = 2;
  uint32 shard_index = 3;
  string output_pid = 4; // empty clears
}

message UpdateShardVisualization {
  nbn.Uuid brain_id = 1;
  uint32 region_id = 2;
  uint32 shard_index = 3;
  bool enabled = 4;
  bool has_focus_region = 5;
  uint32 focus_region_id = 6;
}

message UpdateShardRuntimeConfig {
  nbn.Uuid brain_id = 1;
  uint32 region_id = 2;
  uint32 shard_index = 3;
  bool cost_enabled = 4;
  bool energy_enabled = 5;
  bool plasticity_enabled = 6;
  float plasticity_rate = 7;
  bool probabilistic_updates = 8;
  bool debug_enabled = 9;
  nbn.Severity debug_min_severity = 10;
  bool homeostasis_enabled = 11;
  HomeostasisTargetMode homeostasis_target_mode = 12;
  HomeostasisUpdateMode homeostasis_update_mode = 13;
  float homeostasis_base_probability = 14;
  uint32 homeostasis_min_step_codes = 15;
  bool homeostasis_energy_coupling_enabled = 16;
  float homeostasis_energy_target_scale = 17;
  float homeostasis_energy_probability_scale = 18;
  float plasticity_delta = 19;
  uint32 plasticity_rebase_threshold = 20;
  float plasticity_rebase_threshold_pct = 21;
  bool remote_cost_enabled = 22;
  sint64 remote_cost_per_batch = 23;
  sint64 remote_cost_per_contribution = 24;
  float cost_tier_a_multiplier = 25;
  float cost_tier_b_multiplier = 26;
  float cost_tier_c_multiplier = 27;
}

message SnapshotOverlayRecord {
  fixed32 from_address = 1;
  fixed32 to_address = 2;
  uint32 strength_code = 3;
}

message CaptureShardSnapshot {
  nbn.Uuid brain_id = 1;
  uint32 region_id = 2;
  uint32 shard_index = 3;
  fixed64 tick_id = 4;
}

message CaptureShardSnapshotAck {
  nbn.Uuid brain_id = 1;
  uint32 region_id = 2;
  uint32 shard_index = 3;
  uint32 neuron_start = 4;
  uint32 neuron_count = 5;
  repeated sint32 buffer_codes = 6;
  bytes enabled_bitset = 7;
  repeated SnapshotOverlayRecord overlays = 8;
  bool success = 9;
  string error = 10;
}

message GetBrainIoInfo {
  nbn.Uuid brain_id = 1;
}

message BrainIoInfo {
  nbn.Uuid brain_id = 1;
  uint32 input_width = 2;
  uint32 output_width = 3;
}

enum ShardPlanMode {
  SHARD_PLAN_SINGLE = 0;
  SHARD_PLAN_FIXED = 1;
  SHARD_PLAN_MAX_NEURONS = 2;
}

message ShardPlan {
  ShardPlanMode mode = 1;
  uint32 shard_count = 2;
  uint32 max_neurons_per_shard = 3;
}

// Requested -> Assigning -> Assigned -> Running.
// Reconcile paths temporarily use Reconciling; any hard failure enters Failed.
enum PlacementLifecycleState {
  PLACEMENT_LIFECYCLE_UNKNOWN = 0;
  PLACEMENT_LIFECYCLE_REQUESTED = 1;
  PLACEMENT_LIFECYCLE_ASSIGNING = 2;
  PLACEMENT_LIFECYCLE_ASSIGNED = 3;
  PLACEMENT_LIFECYCLE_RUNNING = 4;
  PLACEMENT_LIFECYCLE_RECONCILING = 5;
  PLACEMENT_LIFECYCLE_FAILED = 6;
  PLACEMENT_LIFECYCLE_TERMINATED = 7;
}

enum PlacementFailureReason {
  PLACEMENT_FAILURE_NONE = 0;
  PLACEMENT_FAILURE_INVALID_BRAIN = 1;
  PLACEMENT_FAILURE_WORKER_UNAVAILABLE = 2;
  PLACEMENT_FAILURE_ASSIGNMENT_REJECTED = 3;
  PLACEMENT_FAILURE_ASSIGNMENT_TIMEOUT = 4;
  PLACEMENT_FAILURE_RECONCILE_MISMATCH = 5;
  PLACEMENT_FAILURE_INTERNAL_ERROR = 6;
}

enum PlacementAssignmentTarget {
  PLACEMENT_TARGET_UNKNOWN = 0;
  PLACEMENT_TARGET_BRAIN_ROOT = 1;
  PLACEMENT_TARGET_SIGNAL_ROUTER = 2;
  PLACEMENT_TARGET_REGION_SHARD = 3;
  PLACEMENT_TARGET_INPUT_COORDINATOR = 4;
  PLACEMENT_TARGET_OUTPUT_COORDINATOR = 5;
}

enum PlacementAssignmentState {
  PLACEMENT_ASSIGNMENT_UNKNOWN = 0;
  PLACEMENT_ASSIGNMENT_PENDING = 1;
  PLACEMENT_ASSIGNMENT_ACCEPTED = 2;
  PLACEMENT_ASSIGNMENT_READY = 3;
  PLACEMENT_ASSIGNMENT_FAILED = 4;
  PLACEMENT_ASSIGNMENT_DRAINING = 5;
}

enum PlacementReconcileState {
  PLACEMENT_RECONCILE_UNKNOWN = 0;
  PLACEMENT_RECONCILE_MATCHED = 1;
  PLACEMENT_RECONCILE_REQUIRES_ACTION = 2;
  PLACEMENT_RECONCILE_FAILED = 3;
}

message PlacementWorkerInventoryRequest { }

message PlacementWorkerInventoryEntry {
  nbn.Uuid worker_node_id = 1;
  string worker_address = 2;
  string worker_root_actor_name = 3;
  bool is_alive = 4;
  fixed64 last_seen_ms = 5;
  uint32 cpu_cores = 6;
  fixed64 ram_free_bytes = 7;
  bool has_gpu = 8;
  fixed64 vram_free_bytes = 9;
  float cpu_score = 10;
  float gpu_score = 11;
  fixed64 capability_epoch = 12;
  fixed64 storage_free_bytes = 13;
}

message PlacementWorkerInventory {
  repeated PlacementWorkerInventoryEntry workers = 1;
  fixed64 snapshot_ms = 2;
}

message PlacementAssignment {
  string assignment_id = 1;
  nbn.Uuid brain_id = 2;
  fixed64 placement_epoch = 3;
  PlacementAssignmentTarget target = 4;
  nbn.Uuid worker_node_id = 5;
  uint32 region_id = 6;
  uint32 shard_index = 7;
  uint32 neuron_start = 8;
  uint32 neuron_count = 9;
  string actor_name = 10;
}

message PlacementAssignmentRequest {
  PlacementAssignment assignment = 1;
}

message PlacementAssignmentAck {
  string assignment_id = 1;
  nbn.Uuid brain_id = 2;
  fixed64 placement_epoch = 3;
  PlacementAssignmentState state = 4;
  bool accepted = 5;
  bool retryable = 6;
  PlacementFailureReason failure_reason = 7;
  string message = 8;
  fixed64 retry_after_ms = 9;
}

message PlacementUnassignmentRequest {
  PlacementAssignment assignment = 1;
}

message PlacementUnassignmentAck {
  string assignment_id = 1;
  nbn.Uuid brain_id = 2;
  fixed64 placement_epoch = 3;
  bool accepted = 4;
  bool retryable = 5;
  PlacementFailureReason failure_reason = 6;
  string message = 7;
  fixed64 retry_after_ms = 8;
}

message PlacementReconcileRequest {
  nbn.Uuid brain_id = 1;
  fixed64 placement_epoch = 2;
}

message PlacementObservedAssignment {
  string assignment_id = 1;
  PlacementAssignmentTarget target = 2;
  nbn.Uuid worker_node_id = 3;
  uint32 region_id = 4;
  uint32 shard_index = 5;
  string actor_pid = 6;
}

message PlacementReconcileReport {
  nbn.Uuid brain_id = 1;
  fixed64 placement_epoch = 2;
  PlacementReconcileState reconcile_state = 3;
  repeated PlacementObservedAssignment assignments = 4;
  PlacementFailureReason failure_reason = 5;
  string message = 6;
}

message RequestPlacement {
  nbn.Uuid brain_id = 1;
  nbn.ArtifactRef base_def = 2;
  nbn.ArtifactRef last_snapshot = 3;
  ShardPlan shard_plan = 4;
  uint32 input_width = 5;
  uint32 output_width = 6;
  string request_id = 7;
  fixed64 requested_ms = 8;
  bool is_recovery = 9;
}

message PlacementAck {
  bool accepted = 1;
  string message = 2;
  fixed64 placement_epoch = 3;
  PlacementLifecycleState lifecycle_state = 4;
  PlacementFailureReason failure_reason = 5;
  fixed64 accepted_ms = 6;
  string request_id = 7;
}

message GetPlacementLifecycle {
  nbn.Uuid brain_id = 1;
}

message PlacementLifecycleInfo {
  nbn.Uuid brain_id = 1;
  fixed64 placement_epoch = 2;
  PlacementLifecycleState lifecycle_state = 3;
  PlacementFailureReason failure_reason = 4;
  PlacementReconcileState reconcile_state = 5;
  fixed64 requested_ms = 6;
  fixed64 updated_ms = 7;
  string request_id = 8;
  ShardPlan shard_plan = 9;
  uint32 registered_shards = 10;
}

message KillBrain {
  nbn.Uuid brain_id = 1;
  string reason = 2;
}

message BrainTerminated {
  nbn.Uuid brain_id = 1;
  string reason = 2;
  nbn.ArtifactRef base_def = 3;       // .nbn
  nbn.ArtifactRef last_snapshot = 4;  // .nbs (optional; may be empty sha)
  sint64 last_energy_remaining = 5;
  sint64 last_tick_cost = 6;
  fixed64 time_ms = 7;
}

message TickCompute {
  fixed64 tick_id = 1;
  float target_tick_hz = 2;
}

message TickComputeDone {
  fixed64 tick_id = 1;
  nbn.Uuid brain_id = 2;
  uint32 region_id = 3;
  nbn.ShardId32 shard_id = 4;

  fixed64 compute_ms = 5;

  sint64 tick_cost_total = 6;
  sint64 cost_accum = 7;
  sint64 cost_activation = 8;
  sint64 cost_reset = 9;
  sint64 cost_distance = 10;
  sint64 cost_remote = 11;

  uint32 fired_count = 12;
  uint32 out_batches = 13;
  uint32 out_contribs = 14;
}

message TickDeliver {
  fixed64 tick_id = 1;
}

message TickDeliverDone {
  fixed64 tick_id = 1;
  nbn.Uuid brain_id = 2;
  fixed64 deliver_ms = 3;
  uint32 delivered_batches = 4;
  uint32 delivered_contribs = 5;
}

message GetHiveMindStatus { }

message SetTickRateOverride {
  bool clear_override = 1;
  float target_tick_hz = 2;
}

message SetTickRateOverrideAck {
  bool accepted = 1;
  string message = 2;
  float target_tick_hz = 3;
  bool has_override = 4;
  float override_tick_hz = 5;
}

message HiveMindStatus {
  fixed64 last_completed_tick_id = 1;
  bool tick_loop_enabled = 2;
  float target_tick_hz = 3;
  uint32 pending_compute = 4;
  uint32 pending_deliver = 5;
  bool reschedule_in_progress = 6;
  uint32 registered_brains = 7;
  uint32 registered_shards = 8;
  bool has_tick_rate_override = 9;
  float tick_rate_override_hz = 10;
}

message GetBrainRouting {
  nbn.Uuid brain_id = 1;
}

message BrainRoutingInfo {
  nbn.Uuid brain_id = 1;
  string brain_root_pid = 2;
  string signal_router_pid = 3;
  uint32 shard_count = 4;
  uint32 routing_count = 5;
}
