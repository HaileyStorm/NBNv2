syntax = "proto3";
package nbn.repro;

option csharp_namespace = "Nbn.Proto.Repro";

import "nbn_common.proto";

enum StrengthSource {
  STRENGTH_BASE_ONLY = 0; // use .nbn only
  STRENGTH_LIVE_CODES = 1; // base + overlay codes from latest .nbs
}

enum SpawnChildPolicy {
  SPAWN_CHILD_DEFAULT_ON = 0; // spawn unless explicitly disabled
  SPAWN_CHILD_NEVER = 1;
  SPAWN_CHILD_ALWAYS = 2;
}

enum PrunePolicy {
  PRUNE_LOWEST_ABS_STRENGTH_FIRST = 0;
  PRUNE_NEW_CONNECTIONS_FIRST = 1;
  PRUNE_RANDOM = 2;
}

message RegionOutDegreeCap {
  uint32 region_id = 1;
  float max_avg_out_degree = 2;
}

message ReproduceLimits {
  // Limits can be specified as absolute and/or percentage.
  // If both are present for the same dimension, the smallest effective limit applies.

  uint32 max_neurons_added_abs = 1;
  float  max_neurons_added_pct = 2;

  uint32 max_neurons_removed_abs = 3;
  float  max_neurons_removed_pct = 4;

  uint32 max_axons_added_abs = 5;
  float  max_axons_added_pct = 6;

  uint32 max_axons_removed_abs = 7;
  float  max_axons_removed_pct = 8;

  uint32 max_regions_added_abs = 9;   // 0 means no region additions
  uint32 max_regions_removed_abs = 10; // 0 means no region removals
}

message ReproduceConfig {
  // Similarity thresholds
  float max_region_span_diff_ratio = 1;
  float max_function_hist_distance = 2;
  float max_connectivity_hist_distance = 3;

  // Region presence handling
  float prob_add_neuron_to_empty_region = 10;
  float prob_remove_last_neuron_from_region = 11;

  // Neuron enable/disable/reactivation within existing regions
  float prob_disable_neuron = 12;
  float prob_reactivate_neuron = 13;

  // Axon handling
  float prob_add_axon = 20;
  float prob_remove_axon = 21;
  float prob_reroute_axon = 22; // reroute an axon (where inbound and outbound neurons both exist), instead of choosing one parents' route
  float prob_reroute_inbound_axon_on_delete = 23; // inbound to deleted neuron
  uint32 inbound_reroute_max_ring_distance = 24; // 0 means unlimited ring distance

  // Value selection for neuron parameter codes
  float prob_choose_parentA = 30;
  float prob_choose_parentB = 31;
  float prob_average = 32;
  float prob_mutate = 33;

  // Function selection/mutation
  float prob_choose_funcA = 40;
  //float prob_choose_funcB = 41; // implicit
  float prob_mutate_func = 42;

  // Strength handling (optional)
  bool strength_transform_enabled = 50;
  float prob_strength_choose_A = 51;
  float prob_strength_choose_B = 52;
  float prob_strength_average = 53;
  float prob_strength_weighted_average = 54;
  float strength_weight_A = 55;
  float strength_weight_B = 56;
  float prob_strength_mutate = 57;

  // Out-degree control
  float max_avg_out_degree_brain = 60;
  PrunePolicy prune_policy = 61;
  repeated RegionOutDegreeCap per_region_out_degree_caps = 62;

  // Limits
  ReproduceLimits limits = 70;

  // Child spawn
  SpawnChildPolicy spawn_child = 80;

  // IO-region neuron-count policy (defaults to true when unset)
  optional bool protect_io_region_neuron_counts = 81;
}

message ManualIoNeuronEdit {
  uint32 region_id = 1; // only input (0) or output (31)
  uint32 neuron_id = 2; // neuron locus within the selected region
}

message ReproduceByBrainIdsRequest {
  nbn.Uuid parentA = 1;
  nbn.Uuid parentB = 2;
  StrengthSource strength_source = 3;
  ReproduceConfig config = 4;
  fixed64 seed = 5;
  repeated ManualIoNeuronEdit manual_io_neuron_adds = 6;
  repeated ManualIoNeuronEdit manual_io_neuron_removes = 7;
  uint32 run_count = 10; // defaults to 1 when unset or 0
}

message ReproduceByArtifactsRequest {
  nbn.ArtifactRef parentA_def = 1; // .nbn
  nbn.ArtifactRef parentA_state = 2; // optional .nbs
  nbn.ArtifactRef parentB_def = 3; // .nbn
  nbn.ArtifactRef parentB_state = 4; // optional .nbs
  StrengthSource strength_source = 5;
  ReproduceConfig config = 6;
  fixed64 seed = 7;
  repeated ManualIoNeuronEdit manual_io_neuron_adds = 8;
  repeated ManualIoNeuronEdit manual_io_neuron_removes = 9;
  uint32 run_count = 10; // defaults to 1 when unset or 0
}

message AssessCompatibilityByBrainIdsRequest {
  nbn.Uuid parentA = 1;
  nbn.Uuid parentB = 2;
  StrengthSource strength_source = 3;
  ReproduceConfig config = 4;
  fixed64 seed = 5;
  repeated ManualIoNeuronEdit manual_io_neuron_adds = 6;
  repeated ManualIoNeuronEdit manual_io_neuron_removes = 7;
  uint32 run_count = 10; // defaults to 1 when unset or 0
}

message AssessCompatibilityByArtifactsRequest {
  nbn.ArtifactRef parentA_def = 1; // .nbn
  nbn.ArtifactRef parentA_state = 2; // optional .nbs
  nbn.ArtifactRef parentB_def = 3; // .nbn
  nbn.ArtifactRef parentB_state = 4; // optional .nbs
  StrengthSource strength_source = 5;
  ReproduceConfig config = 6;
  fixed64 seed = 7;
  repeated ManualIoNeuronEdit manual_io_neuron_adds = 8;
  repeated ManualIoNeuronEdit manual_io_neuron_removes = 9;
  uint32 run_count = 10; // defaults to 1 when unset or 0
}

message SimilarityReport {
  bool compatible = 1;
  string abort_reason = 2;

  float region_span_score = 10;
  float function_score = 11;
  float connectivity_score = 12;
  float similarity_score = 13;

  uint32 regions_present_A = 20;
  uint32 regions_present_B = 21;
  uint32 regions_present_child = 22;
}

message MutationSummary {
  uint32 neurons_added = 1;
  uint32 neurons_removed = 2;
  uint32 axons_added = 3;
  uint32 axons_removed = 4;
  uint32 axons_rerouted = 5;
  uint32 functions_mutated = 6;
  uint32 strength_codes_changed = 7;
}

message ReproduceRunOutcome {
  uint32 run_index = 1;
  fixed64 seed = 2;
  SimilarityReport report = 3;
  MutationSummary summary = 4;

  nbn.ArtifactRef child_def = 10; // .nbn when synthesized
  bool spawned = 11;
  nbn.Uuid child_brain_id = 12; // valid if spawned==true
}

message ReproduceResult {
  SimilarityReport report = 1;
  MutationSummary summary = 2;

  nbn.ArtifactRef child_def = 10; // .nbn
  bool spawned = 11;
  nbn.Uuid child_brain_id = 12; // valid if spawned==true
  repeated ReproduceRunOutcome runs = 20; // deterministic order by run_index
  uint32 requested_run_count = 21; // normalized effective run count
}
